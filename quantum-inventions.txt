سأضيف جميع هذه الميزات المتقدمة. دعني أقرأ الملفات أولاً ثم أنفذها بالتوازي.

سأقوم بإنشاء جميع الميزات المتقدمة الآن:

 {\\n    try {\\n      console.log('جاري تحميل ملف GeoTIFF...');\\n      \\n      const arrayBuffer = await file.arrayBuffer();\\n      const tiff = await fromArrayBuffer(arrayBuffer);\\n      \\n      // قراءة معلومات الصورة\\n      const image = await tiff.getImage();\\n      const width = image.getWidth();\\n      const height = image.getHeight();\\n      const samplesPerPixel = image.getSamplesPerPixel();\\n      \\n      console.log(`أبعاد الصورة: ${width}x${height}, القنوات: ${samplesPerPixel}`);\\n      \\n      // قراءة البيانات\\n      const rasters = await image.readRasters();\\n      \\n      // تحويل البيانات إلى Float32Array\\n      const bands: MultiBandImage['bands'] = {};\\n      \\n      // تعيين القنوات بناءً على عددها\\n      if (samplesPerPixel >= 4) {\\n        // افتراض ترتيب R, G, B, NIR للصور رباعية القنوات\\n        bands.B4 = this.normalizeToFloat32(rasters[0] as ArrayLike);\\n        bands.B3 = this.normalizeToFloat32(rasters[1] as ArrayLike);\\n        bands.B2 = this.normalizeToFloat32(rasters[2] as ArrayLike);\\n        bands.B8 = this.normalizeToFloat32(rasters[3] as ArrayLike);\\n        \\n        if (samplesPerPixel >= 5) {\\n          bands.B11 = this.normalizeToFloat32(rasters[4] as ArrayLike);\\n        }\\n        if (samplesPerPixel >= 6) {\\n          bands.B5 = this.normalizeToFloat32(rasters[5] as ArrayLike);\\n        }\\n      } else if (samplesPerPixel === 3) {\\n        // RGB فقط\\n        bands.B4 = this.normalizeToFloat32(rasters[0] as ArrayLike);\\n        bands.B3 = this.normalizeToFloat32(rasters[1] as ArrayLike);\\n        bands.B2 = this.normalizeToFloat32(rasters[2] as ArrayLike);\\n        // تقريب NIR من RGB\\n        bands.B8 = this.approximateNIR(bands.B4, bands.B3, bands.B2);\\n      } else if (samplesPerPixel === 1) {\\n        // قناة واحدة (ربما NDVI مسبق الحساب)\\n        bands.B4 = this.normalizeToFloat32(rasters[0] as ArrayLike);\\n        bands.B3 = new Float32Array(bands.B4.length).fill(0.5);\\n        bands.B2 = new Float32Array(bands.B4.length).fill(0.5);\\n        bands.B8 = new Float32Array(bands.B4.length).fill(0.5);\\n      }\\n      \\n      // استخراج metadata\\n      const geoKeys = image.getGeoKeys();\\n      const metadata: MultiBandImage['metadata'] = {\\n        resolution: image.getResolution()?.[0],\\n        satellite: this.detectSatellite(file.name, samplesPerPixel)\\n      };\\n      \\n      if (geoKeys?.GeographicTypeGeoKey) {\\n        metadata.crs = `EPSG:${geoKeys.GeographicTypeGeoKey}`;\\n      }\\n      \\n      const bbox = image.getBoundingBox();\\n      if (bbox) {\\n        metadata.bounds = bbox as [number, number, number, number];\\n      }\\n      \\n      console.log('تم تحميل GeoTIFF بنجاح');\\n      \\n      return {\\n        success: true,\\n        image: {\\n          bands,\\n          width,\\n          height,\\n          metadata\\n        }\\n      };\\n      \\n    } catch (error) {\\n      console.error('خطأ في تحميل GeoTIFF:', error);\\n      return {\\n        success: false,\\n        error: error instanceof Error ? error.message : 'خطأ غير معروف'\\n      };\\n    }\\n  }\\n  \\n  /**\\n   * تحويل البيانات إلى Float32Array مع التطبيع\\n   */\\n  private static normalizeToFloat32(data: ArrayLike): Float32Array {\\n    const result = new Float32Array(data.length);\\n    \\n    // إيجاد الحد الأقصى للتطبيع\\n    let max = 0;\\n    for (let i = 0; i < data.length; i++) {\\n      if (data[i] > max && isFinite(data[i])) max = data[i];\\n    }\\n    \\n    // تطبيع إلى 0-1\\n    const scale = max > 0 ? 1 / max : 1;\\n    for (let i = 0; i < data.length; i++) {\\n      const val = data[i];\\n      result[i] = isFinite(val) ? Math.max(0, Math.min(1, val * scale)) : 0;\\n    }\\n    \\n    return result;\\n  }\\n  \\n  /**\\n   * تقريب قناة NIR من RGB\\n   */\\n  private static approximateNIR(red: Float32Array, green: Float32Array, blue: Float32Array): Float32Array {\\n    const nir = new Float32Array(red.length);\\n    \\n    for (let i = 0; i < red.length; i++) {\\n      // تقريب NIR باستخدام علاقة معكوسة مع الأحمر\\n      nir[i] = Math.max(0, Math.min(1, \\n        0.7 * green[i] + 0.5 * red[i] - 0.3 * blue[i] + 0.1\\n      ));\\n    }\\n    \\n    return nir;\\n  }\\n  \\n  /**\\n   * اكتشاف نوع القمر الصناعي\\n   */\\n  private static detectSatellite(filename: string, bands: number): string {\\n    const lower = filename.toLowerCase();\\n    \\n    if (lower.includes('s2') || lower.includes('sentinel')) {\\n      return 'Sentinel-2';\\n    } else if (lower.includes('l8') || lower.includes('landsat')) {\\n      return 'Landsat-8';\\n    } else if (bands >= 4) {\\n      return 'Multi-spectral';\\n    }\\n    \\n    return 'Unknown';\\n  }\\n  \\n  /**\\n   * تحويل MultiBandImage إلى SNAPBands\\n   */\\n  static toSNAPBands(image: MultiBandImage): {\\n    B2: Float32Array;\\n    B3: Float32Array;\\n    B4: Float32Array;\\n    B8: Float32Array;\\n    B11?: Float32Array;\\n    B5?: Float32Array;\\n    B6?: Float32Array;\\n    B7?: Float32Array;\\n    width: number;\\n    height: number;\\n  } {\\n    return {\\n      B2: image.bands.B2 || new Float32Array(image.width * image.height),\\n      B3: image.bands.B3 || new Float32Array(image.width * image.height),\\n      B4: image.bands.B4 || new Float32Array(image.width * image.height),\\n      B8: image.bands.B8 || new Float32Array(image.width * image.height),\\n      B11: image.bands.B11,\\n      B5: image.bands.B5,\\n      B6: image.bands.B6,\\n      B7: image.bands.B7,\\n      width: image.width,\\n      height: image.height\\n    };\\n  }\\n  \\n  /**\\n   * فحص ما إذا كان الملف GeoTIFF\\n   */\\n  static isGeoTIFF(file: File): boolean {\\n    const ext = file.name.toLowerCase();\\n    return ext.endsWith('.tif') || ext.endsWith('.tiff') || ext.endsWith('.geotiff');\\n  }\\n}\\n\"}">

;\\n  interpretation: string;\\n}\\n\\nexport interface ImageCharacteristics {\\n  dominantColor: 'green' | 'blue' | 'brown' | 'urban' | 'mixed';\\n  vegetationLevel: 'high' | 'medium' | 'low' | 'none';\\n  waterPresence: 'high' | 'medium' | 'low' | 'none';\\n  urbanDensity: 'high' | 'medium' | 'low' | 'none';\\n  soilExposure: 'high' | 'medium' | 'low' | 'none';\\n  seasonEstimate: 'summer' | 'winter' | 'spring' | 'autumn' | 'unknown';\\n}\\n\\nexport interface AIAnalysisResult {\\n  characteristics: ImageCharacteristics;\\n  topRecommendations: AIRecommendation[];\\n  overallAssessment: string;\\n  suggestedWorkflow: string[];\\n  confidenceScore: number;\\n}\\n\\nexport class AISpectralAssistant {\\n  \\n  /**\\n   * تحليل خصائص الصورة\\n   */\\n  static analyzeCharacteristics(snapResult: SNAPAnalysisResult): ImageCharacteristics {\\n    const ndviMean = snapResult.indices.ndvi?.mean ?? 0;\\n    const ndwiMean = snapResult.indices.ndwi?.mean ?? 0;\\n    const ndbiMean = snapResult.indices.ndbi?.mean ?? 0;\\n    const bsiMean = snapResult.indices.bsi?.mean ?? 0;\\n    \\n    // تحديد اللون السائد\\n    let dominantColor: ImageCharacteristics['dominantColor'] = 'mixed';\\n    if (ndviMean > 0.3) dominantColor = 'green';\\n    else if (ndwiMean > 0.2) dominantColor = 'blue';\\n    else if (ndbiMean > 0.1) dominantColor = 'urban';\\n    else if (bsiMean > 0.2) dominantColor = 'brown';\\n    \\n    // تحديد مستوى الغطاء النباتي\\n    let vegetationLevel: ImageCharacteristics['vegetationLevel'] = 'none';\\n    if (ndviMean > 0.5) vegetationLevel = 'high';\\n    else if (ndviMean > 0.3) vegetationLevel = 'medium';\\n    else if (ndviMean > 0.1) vegetationLevel = 'low';\\n    \\n    // تحديد وجود المياه\\n    let waterPresence: ImageCharacteristics['waterPresence'] = 'none';\\n    if (ndwiMean > 0.3) waterPresence = 'high';\\n    else if (ndwiMean > 0.15) waterPresence = 'medium';\\n    else if (ndwiMean > 0.05) waterPresence = 'low';\\n    \\n    // تحديد الكثافة الحضرية\\n    let urbanDensity: ImageCharacteristics['urbanDensity'] = 'none';\\n    if (ndbiMean > 0.3) urbanDensity = 'high';\\n    else if (ndbiMean > 0.15) urbanDensity = 'medium';\\n    else if (ndbiMean > 0.05) urbanDensity = 'low';\\n    \\n    // تحديد تعرض التربة\\n    let soilExposure: ImageCharacteristics['soilExposure'] = 'none';\\n    if (bsiMean > 0.4) soilExposure = 'high';\\n    else if (bsiMean > 0.2) soilExposure = 'medium';\\n    else if (bsiMean > 0.1) soilExposure = 'low';\\n    \\n    // تقدير الموسم بناءً على الغطاء النباتي\\n    let seasonEstimate: ImageCharacteristics['seasonEstimate'] = 'unknown';\\n    if (ndviMean > 0.5) seasonEstimate = 'summer';\\n    else if (ndviMean > 0.3 && ndwiMean > 0.1) seasonEstimate = 'spring';\\n    else if (ndviMean < 0.2 && bsiMean > 0.2) seasonEstimate = 'autumn';\\n    else if (ndviMean < 0.1) seasonEstimate = 'winter';\\n    \\n    return {\\n      dominantColor,\\n      vegetationLevel,\\n      waterPresence,\\n      urbanDensity,\\n      soilExposure,\\n      seasonEstimate\\n    };\\n  }\\n  \\n  /**\\n   * اختيار أفضل 3 مؤشرات للصورة\\n   */\\n  static selectBestIndices(\\n    snapResult: SNAPAnalysisResult,\\n    characteristics: ImageCharacteristics\\n  ): AIRecommendation[] {\\n    const recommendations: AIRecommendation[] = [];\\n    \\n    // قواعد اختيار المؤشرات بناءً على الخصائص\\n    if (characteristics.vegetationLevel !== 'none') {\\n      // للنباتات\\n      recommendations.push({\\n        index: 'NDVI',\\n        arabicName: 'مؤشر الغطاء النباتي',\\n        reason: 'الصورة تحتوي على غطاء نباتي واضح',\\n        priority: characteristics.vegetationLevel === 'high' ? 1 : 2,\\n        suggestedParams: { L: 0.5, gamma: 1.2 },\\n        interpretation: this.getNDVIInterpretation(snapResult.indices.ndvi?.mean ?? 0)\\n      });\\n      \\n      // SAVI للنباتات المتفرقة\\n      if (characteristics.soilExposure !== 'none') {\\n        recommendations.push({\\n          index: 'SAVI',\\n          arabicName: 'مؤشر الغطاء النباتي المعدل للتربة',\\n          reason: 'وجود تربة مكشوفة يستدعي تصحيح تأثير التربة',\\n          priority: 2,\\n          suggestedParams: { L: characteristics.soilExposure === 'high' ? 0.25 : 0.5 },\\n          interpretation: 'تصحيح تأثير التربة للحصول على قراءة نباتية أدق'\\n        });\\n      }\\n      \\n      // EVI للغابات الكثيفة\\n      if (characteristics.vegetationLevel === 'high') {\\n        recommendations.push({\\n          index: 'EVI',\\n          arabicName: 'مؤشر الغطاء النباتي المحسّن',\\n          reason: 'الغطاء النباتي الكثيف يتطلب EVI لتجنب التشبع',\\n          priority: 2,\\n          suggestedParams: { C1: 6, C2: 7.5, L: 1, G: 2.5 },\\n          interpretation: 'مناسب للغابات الكثيفة والمناطق الزراعية'\\n        });\\n      }\\n    }\\n    \\n    if (characteristics.waterPresence !== 'none') {\\n      recommendations.push({\\n        index: 'NDWI',\\n        arabicName: 'مؤشر المياه',\\n        reason: 'اكتشاف مسطحات مائية في الصورة',\\n        priority: characteristics.waterPresence === 'high' ? 1 : 3,\\n        suggestedParams: { threshold: 0.3 },\\n        interpretation: this.getNDWIInterpretation(snapResult.indices.ndwi?.mean ?? 0)\\n      });\\n      \\n      // NDMI للرطوبة\\n      recommendations.push({\\n        index: 'NDMI',\\n        arabicName: 'مؤشر الرطوبة',\\n        reason: 'قياس محتوى الرطوبة في النباتات',\\n        priority: 3,\\n        suggestedParams: { threshold: 0.2 },\\n        interpretation: 'مفيد لمراقبة الجفاف والري'\\n      });\\n    }\\n    \\n    if (characteristics.urbanDensity !== 'none') {\\n      recommendations.push({\\n        index: 'NDBI',\\n        arabicName: 'مؤشر المناطق المبنية',\\n        reason: 'اكتشاف مناطق حضرية أو مبنية',\\n        priority: characteristics.urbanDensity === 'high' ? 1 : 3,\\n        suggestedParams: { threshold: 0.1 },\\n        interpretation: this.getNDBIInterpretation(snapResult.indices.ndbi?.mean ?? 0)\\n      });\\n    }\\n    \\n    if (characteristics.soilExposure === 'high') {\\n      recommendations.push({\\n        index: 'BSI',\\n        arabicName: 'مؤشر التربة العارية',\\n        reason: 'تربة مكشوفة تحتاج تحليل',\\n        priority: 2,\\n        suggestedParams: { threshold: 0.2 },\\n        interpretation: 'مناسب لرصد التصحر والتآكل'\\n      });\\n    }\\n    \\n    // ترتيب حسب الأولوية وإرجاع أفضل 3\\n    return recommendations\\n      .sort((a, b) => a.priority - b.priority)\\n      .slice(0, 3);\\n  }\\n  \\n  /**\\n   * تحليل كامل بالذكاء الاصطناعي\\n   */\\n  static async fullAnalysis(snapResult: SNAPAnalysisResult): Promise {\\n    const characteristics = this.analyzeCharacteristics(snapResult);\\n    const topRecommendations = this.selectBestIndices(snapResult, characteristics);\\n    \\n    // تقييم شامل\\n    const overallAssessment = this.generateAssessment(characteristics, snapResult);\\n    \\n    // سير العمل المقترح\\n    const suggestedWorkflow = this.generateWorkflow(characteristics);\\n    \\n    // درجة الثقة\\n    const confidenceScore = this.calculateConfidence(snapResult);\\n    \\n    return {\\n      characteristics,\\n      topRecommendations,\\n      overallAssessment,\\n      suggestedWorkflow,\\n      confidenceScore\\n    };\\n  }\\n  \\n  /**\\n   * توليد تقييم شامل\\n   */\\n  private static generateAssessment(\\n    chars: ImageCharacteristics,\\n    snapResult: SNAPAnalysisResult\\n  ): string {\\n    const parts: string[] = [];\\n    \\n    if (chars.vegetationLevel === 'high') {\\n      parts.push('الصورة تُظهر غطاء نباتي كثيف وصحي');\\n    } else if (chars.vegetationLevel === 'medium') {\\n      parts.push('الصورة تحتوي على غطاء نباتي متوسط');\\n    }\\n    \\n    if (chars.waterPresence === 'high') {\\n      parts.push('مع وجود مسطحات مائية واضحة');\\n    }\\n    \\n    if (chars.urbanDensity === 'high') {\\n      parts.push('والمنطقة ذات كثافة حضرية عالية');\\n    }\\n    \\n    if (chars.soilExposure === 'high') {\\n      parts.push('مع تربة مكشوفة تحتاج مراقبة');\\n    }\\n    \\n    const ndviMean = snapResult.indices.ndvi?.mean ?? 0;\\n    if (ndviMean > 0.5) {\\n      parts.push('(صحة نباتية ممتازة)');\\n    } else if (ndviMean > 0.3) {\\n      parts.push('(صحة نباتية جيدة)');\\n    } else if (ndviMean > 0.1) {\\n      parts.push('(صحة نباتية متوسطة)');\\n    }\\n    \\n    return parts.join('، ') || 'الصورة متنوعة التضاريس';\\n  }\\n  \\n  /**\\n   * توليد سير العمل المقترح\\n   */\\n  private static generateWorkflow(chars: ImageCharacteristics): string[] {\\n    const workflow: string[] = [];\\n    \\n    workflow.push('1. مراجعة الخريطة الحرارية العامة');\\n    \\n    if (chars.vegetationLevel !== 'none') {\\n      workflow.push('2. فحص خريطة NDVI للغطاء النباتي');\\n      if (chars.soilExposure !== 'none') {\\n        workflow.push('3. مقارنة مع SAVI لتصحيح تأثير التربة');\\n      }\\n    }\\n    \\n    if (chars.waterPresence !== 'none') {\\n      workflow.push(`${workflow.length + 1}. تحليل NDWI للمسطحات المائية`);\\n    }\\n    \\n    if (chars.urbanDensity !== 'none') {\\n      workflow.push(`${workflow.length + 1}. فحص NDBI للمناطق الحضرية`);\\n    }\\n    \\n    workflow.push(`${workflow.length + 1}. تصدير التقرير النهائي`);\\n    \\n    return workflow;\\n  }\\n  \\n  /**\\n   * حساب درجة الثقة\\n   */\\n  private static calculateConfidence(snapResult: SNAPAnalysisResult): number {\\n    let score = 0;\\n    let count = 0;\\n    \\n    for (const [key, index] of Object.entries(snapResult.indices)) {\\n      if (index && index.validPixels) {\\n        const pixelRatio = index.validPixels / (snapResult.statistics.pixelCount || 1);\\n        score += pixelRatio;\\n        count++;\\n      }\\n    }\\n    \\n    return count > 0 ? Math.min(1, score / count) : 0.5;\\n  }\\n  \\n  /**\\n   * تفسير قيم NDVI\\n   */\\n  private static getNDVIInterpretation(value: number): string {\\n    if (value >= 0.7) return 'غطاء نباتي كثيف جداً (غابات/محاصيل ناضجة)';\\n    if (value >= 0.5) return 'غطاء نباتي صحي (مزارع/حدائق)';\\n    if (value >= 0.3) return 'غطاء نباتي متوسط (مراعي/شجيرات)';\\n    if (value >= 0.1) return 'غطاء نباتي ضعيف (أعشاب متفرقة)';\\n    if (value >= 0) return 'أرض عارية أو صخور';\\n    return 'مياه أو ظلال';\\n  }\\n  \\n  /**\\n   * تفسير قيم NDWI\\n   */\\n  private static getNDWIInterpretation(value: number): string {\\n    if (value >= 0.5) return 'مسطح مائي عميق';\\n    if (value >= 0.3) return 'مياه سطحية واضحة';\\n    if (value >= 0.1) return 'رطوبة عالية أو مستنقعات';\\n    return 'أرض جافة';\\n  }\\n  \\n  /**\\n   * تفسير قيم NDBI\\n   */\\n  private static getNDBIInterpretation(value: number): string {\\n    if (value >= 0.4) return 'منطقة حضرية كثيفة';\\n    if (value >= 0.2) return 'منطقة سكنية متوسطة';\\n    if (value >= 0.1) return 'بنية تحتية متفرقة';\\n    return 'منطقة طبيعية';\\n  }\\n}\\n\"}">

 {\\n    const startTime = performance.now();\\n    \\n    try {\\n      // التحقق من تطابق الأبعاد\\n      if (beforeImage.width !== afterImage.width || beforeImage.height !== afterImage.height) {\\n        // تغيير حجم الصورة الأصغر\\n        const [before, after] = this.normalizeImageSizes(beforeImage, afterImage);\\n        beforeImage = before;\\n        afterImage = after;\\n      }\\n      \\n      const { width, height } = beforeImage;\\n      const totalPixels = width * height;\\n      \\n      // حساب الفروقات\\n      const diffData = new Float32Array(totalPixels);\\n      const beforeData = beforeImage.data;\\n      const afterData = afterImage.data;\\n      \\n      let changedPixels = 0;\\n      \\n      for (let i = 0; i < totalPixels; i++) {\\n        const idx = i * 4;\\n        \\n        // حساب الفرق لكل قناة\\n        const rDiff = Math.abs(afterData[idx] - beforeData[idx]) / 255;\\n        const gDiff = Math.abs(afterData[idx + 1] - beforeData[idx + 1]) / 255;\\n        const bDiff = Math.abs(afterData[idx + 2] - beforeData[idx + 2]) / 255;\\n        \\n        // الفرق الإجمالي\\n        const totalDiff = (rDiff + gDiff + bDiff) / 3;\\n        diffData[i] = totalDiff;\\n        \\n        if (totalDiff > sensitivity) {\\n          changedPixels++;\\n        }\\n      }\\n      \\n      // توليد خريطة حرارية للتغيرات\\n      const changeHeatmap = this.generateChangeHeatmap(diffData, width, height);\\n      \\n      // توليد صورة الفرق\\n      const differenceImage = this.generateDifferenceImage(\\n        beforeData, afterData, width, height\\n      );\\n      \\n      // اكتشاف مناطق التغير\\n      const regions = this.detectChangeRegions(diffData, width, height, sensitivity);\\n      \\n      // تحليل تغيرات المواد\\n      const materialChanges = this.analyzeMaterialChanges(beforeImage, afterImage);\\n      \\n      // التفسير\\n      const overallChangePercentage = (changedPixels / totalPixels) * 100;\\n      const interpretation = this.generateInterpretation(overallChangePercentage, materialChanges);\\n      \\n      const processingTime = performance.now() - startTime;\\n      \\n      return {\\n        success: true,\\n        overallChangePercentage,\\n        changeHeatmap,\\n        differenceImage,\\n        regions,\\n        materialChanges,\\n        statistics: {\\n          totalPixels,\\n          changedPixels,\\n          significantChangeThreshold: sensitivity,\\n          processingTime\\n        },\\n        interpretation\\n      };\\n      \\n    } catch (error) {\\n      return {\\n        success: false,\\n        overallChangePercentage: 0,\\n        changeHeatmap: '',\\n        differenceImage: '',\\n        regions: [],\\n        materialChanges: [],\\n        statistics: {\\n          totalPixels: 0,\\n          changedPixels: 0,\\n          significantChangeThreshold: sensitivity,\\n          processingTime: performance.now() - startTime\\n        },\\n        interpretation: '',\\n        error: error instanceof Error ? error.message : 'خطأ غير معروف'\\n      };\\n    }\\n  }\\n  \\n  /**\\n   * توحيد أحجام الصور\\n   */\\n  private static normalizeImageSizes(img1: ImageData, img2: ImageData): [ImageData, ImageData] {\\n    const targetWidth = Math.min(img1.width, img2.width);\\n    const targetHeight = Math.min(img1.height, img2.height);\\n    \\n    const resize = (img: ImageData): ImageData => {\\n      if (img.width === targetWidth && img.height === targetHeight) {\\n        return img;\\n      }\\n      \\n      const canvas = document.createElement('canvas');\\n      canvas.width = targetWidth;\\n      canvas.height = targetHeight;\\n      const ctx = canvas.getContext('2d')!;\\n      \\n      // رسم الصورة الأصلية\\n      const tempCanvas = document.createElement('canvas');\\n      tempCanvas.width = img.width;\\n      tempCanvas.height = img.height;\\n      const tempCtx = tempCanvas.getContext('2d')!;\\n      tempCtx.putImageData(img, 0, 0);\\n      \\n      ctx.drawImage(tempCanvas, 0, 0, targetWidth, targetHeight);\\n      return ctx.getImageData(0, 0, targetWidth, targetHeight);\\n    };\\n    \\n    return [resize(img1), resize(img2)];\\n  }\\n  \\n  /**\\n   * توليد خريطة حرارية للتغيرات\\n   */\\n  private static generateChangeHeatmap(\\n    diffData: Float32Array,\\n    width: number,\\n    height: number\\n  ): string {\\n    const canvas = document.createElement('canvas');\\n    canvas.width = width;\\n    canvas.height = height;\\n    const ctx = canvas.getContext('2d')!;\\n    const imageData = ctx.createImageData(width, height);\\n    \\n    for (let i = 0; i < diffData.length; i++) {\\n      const idx = i * 4;\\n      const value = diffData[i];\\n      \\n      // تدرج من الأزرق (لا تغير) إلى الأحمر (تغير كبير)\\n      let r: number, g: number, b: number;\\n      \\n      if (value < 0.1) {\\n        // لا تغير - أزرق\\n        r = 0; g = 0; b = 150;\\n      } else if (value < 0.25) {\\n        // تغير طفيف - أخضر\\n        r = 0; g = 200; b = 0;\\n      } else if (value < 0.5) {\\n        // تغير متوسط - أصفر\\n        r = 255; g = 255; b = 0;\\n      } else if (value < 0.75) {\\n        // تغير كبير - برتقالي\\n        r = 255; g = 150; b = 0;\\n      } else {\\n        // تغير شديد - أحمر\\n        r = 255; g = 0; b = 0;\\n      }\\n      \\n      imageData.data[idx] = r;\\n      imageData.data[idx + 1] = g;\\n      imageData.data[idx + 2] = b;\\n      imageData.data[idx + 3] = 200;\\n    }\\n    \\n    ctx.putImageData(imageData, 0, 0);\\n    return canvas.toDataURL('image/png');\\n  }\\n  \\n  /**\\n   * توليد صورة الفرق المباشرة\\n   */\\n  private static generateDifferenceImage(\\n    beforeData: Uint8ClampedArray,\\n    afterData: Uint8ClampedArray,\\n    width: number,\\n    height: number\\n  ): string {\\n    const canvas = document.createElement('canvas');\\n    canvas.width = width;\\n    canvas.height = height;\\n    const ctx = canvas.getContext('2d')!;\\n    const imageData = ctx.createImageData(width, height);\\n    \\n    for (let i = 0; i < beforeData.length; i += 4) {\\n      // حساب الفرق مع الحفاظ على الاتجاه\\n      const rDiff = afterData[i] - beforeData[i];\\n      const gDiff = afterData[i + 1] - beforeData[i + 1];\\n      const bDiff = afterData[i + 2] - beforeData[i + 2];\\n      \\n      // تحويل الفروقات إلى ألوان مرئية\\n      // زيادة = أخضر، نقصان = أحمر\\n      imageData.data[i] = rDiff > 0 ? 0 : Math.min(255, Math.abs(rDiff) * 2);\\n      imageData.data[i + 1] = gDiff > 0 ? Math.min(255, gDiff * 2) : 0;\\n      imageData.data[i + 2] = 128; // ثابت للتباين\\n      imageData.data[i + 3] = 255;\\n    }\\n    \\n    ctx.putImageData(imageData, 0, 0);\\n    return canvas.toDataURL('image/png');\\n  }\\n  \\n  /**\\n   * اكتشاف مناطق التغير\\n   */\\n  private static detectChangeRegions(\\n    diffData: Float32Array,\\n    width: number,\\n    height: number,\\n    threshold: number\\n  ): ChangeRegion[] {\\n    const regions: ChangeRegion[] = [];\\n    const visited = new Set();\\n    const gridSize = 32; // تقسيم الصورة إلى شبكة\\n    \\n    for (let gy = 0; gy < Math.ceil(height / gridSize); gy++) {\\n      for (let gx = 0; gx < Math.ceil(width / gridSize); gx++) {\\n        const startX = gx * gridSize;\\n        const startY = gy * gridSize;\\n        const endX = Math.min(startX + gridSize, width);\\n        const endY = Math.min(startY + gridSize, height);\\n        \\n        let totalChange = 0;\\n        let pixelCount = 0;\\n        \\n        for (let y = startY; y < endY; y++) {\\n          for (let x = startX; x < endX; x++) {\\n            const idx = y * width + x;\\n            totalChange += diffData[idx];\\n            pixelCount++;\\n          }\\n        }\\n        \\n        const avgChange = totalChange / pixelCount;\\n        \\n        if (avgChange > threshold) {\\n          regions.push({\\n            x: startX,\\n            y: startY,\\n            width: endX - startX,\\n            height: endY - startY,\\n            changeType: 'other',\\n            changeIntensity: avgChange,\\n            areaPercentage: (pixelCount / (width * height)) * 100\\n          });\\n        }\\n      }\\n    }\\n    \\n    return regions.sort((a, b) => b.changeIntensity - a.changeIntensity);\\n  }\\n  \\n  /**\\n   * تحليل تغيرات المواد\\n   */\\n  private static analyzeMaterialChanges(\\n    beforeImage: ImageData,\\n    afterImage: ImageData\\n  ): MaterialChange[] {\\n    const materials: MaterialChange[] = [];\\n    \\n    // حساب متوسطات الألوان قبل وبعد\\n    const beforeStats = this.calculateColorStats(beforeImage);\\n    const afterStats = this.calculateColorStats(afterImage);\\n    \\n    // الغطاء النباتي (الأخضر)\\n    const vegBefore = (beforeStats.green - beforeStats.red) / (beforeStats.green + beforeStats.red + 1);\\n    const vegAfter = (afterStats.green - afterStats.red) / (afterStats.green + afterStats.red + 1);\\n    const vegChange = vegAfter - vegBefore;\\n    \\n    materials.push({\\n      material: 'الغطاء النباتي',\\n      beforePercentage: Math.max(0, vegBefore * 100),\\n      afterPercentage: Math.max(0, vegAfter * 100),\\n      changeRate: vegChange * 100,\\n      trend: vegChange > 0.05 ? 'increase' : vegChange < -0.05 ? 'decrease' : 'stable'\\n    });\\n    \\n    // المياه (الأزرق)\\n    const waterBefore = (beforeStats.blue - beforeStats.red) / (beforeStats.blue + beforeStats.red + 1);\\n    const waterAfter = (afterStats.blue - afterStats.red) / (afterStats.blue + afterStats.red + 1);\\n    const waterChange = waterAfter - waterBefore;\\n    \\n    materials.push({\\n      material: 'المسطحات المائية',\\n      beforePercentage: Math.max(0, waterBefore * 100),\\n      afterPercentage: Math.max(0, waterAfter * 100),\\n      changeRate: waterChange * 100,\\n      trend: waterChange > 0.05 ? 'increase' : waterChange < -0.05 ? 'decrease' : 'stable'\\n    });\\n    \\n    // المناطق المبنية (الرمادي)\\n    const urbanBefore = Math.abs(beforeStats.red - beforeStats.green) < 20 ? beforeStats.brightness : 0;\\n    const urbanAfter = Math.abs(afterStats.red - afterStats.green) < 20 ? afterStats.brightness : 0;\\n    const urbanChange = (urbanAfter - urbanBefore) / 255;\\n    \\n    materials.push({\\n      material: 'المناطق الحضرية',\\n      beforePercentage: (urbanBefore / 255) * 100,\\n      afterPercentage: (urbanAfter / 255) * 100,\\n      changeRate: urbanChange * 100,\\n      trend: urbanChange > 0.05 ? 'increase' : urbanChange < -0.05 ? 'decrease' : 'stable'\\n    });\\n    \\n    return materials;\\n  }\\n  \\n  /**\\n   * حساب إحصائيات الألوان\\n   */\\n  private static calculateColorStats(image: ImageData): {\\n    red: number;\\n    green: number;\\n    blue: number;\\n    brightness: number;\\n  } {\\n    const data = image.data;\\n    let rSum = 0, gSum = 0, bSum = 0;\\n    const pixelCount = data.length / 4;\\n    \\n    for (let i = 0; i < data.length; i += 4) {\\n      rSum += data[i];\\n      gSum += data[i + 1];\\n      bSum += data[i + 2];\\n    }\\n    \\n    return {\\n      red: rSum / pixelCount,\\n      green: gSum / pixelCount,\\n      blue: bSum / pixelCount,\\n      brightness: (rSum + gSum + bSum) / (3 * pixelCount)\\n    };\\n  }\\n  \\n  /**\\n   * توليد تفسير النتائج\\n   */\\n  private static generateInterpretation(\\n    changePercentage: number,\\n    materialChanges: MaterialChange[]\\n  ): string {\\n    const parts: string[] = [];\\n    \\n    if (changePercentage < 5) {\\n      parts.push('التغيرات طفيفة جداً بين الصورتين');\\n    } else if (changePercentage < 15) {\\n      parts.push('تغيرات متوسطة ملحوظة');\\n    } else if (changePercentage < 30) {\\n      parts.push('تغيرات كبيرة في المنطقة');\\n    } else {\\n      parts.push('تغيرات جذرية واسعة النطاق');\\n    }\\n    \\n    for (const mat of materialChanges) {\\n      if (mat.trend === 'increase' && mat.changeRate > 5) {\\n        parts.push(`زيادة في ${mat.material} بنسبة ${mat.changeRate.toFixed(1)}%`);\\n      } else if (mat.trend === 'decrease' && mat.changeRate < -5) {\\n        parts.push(`انخفاض في ${mat.material} بنسبة ${Math.abs(mat.changeRate).toFixed(1)}%`);\\n      }\\n    }\\n    \\n    return parts.join('، ');\\n  }\\n}\\n\"}">

 = {}\\n  ): Promise {\\n    const startTime = performance.now();\\n    const opts = { ...this.DEFAULT_OPTIONS, ...options };\\n    \\n    try {\\n      const { width, height } = imageData;\\n      const step = Math.max(1, Math.floor(1 / opts.resolution));\\n      \\n      const gridWidth = Math.floor(width / step);\\n      const gridHeight = Math.floor(height / step);\\n      \\n      // استخراج خريطة الارتفاع من الصورة\\n      const heightMap = this.extractHeightMap(imageData, ndviData, step);\\n      \\n      // تنعيم خريطة الارتفاع\\n      const smoothedHeightMap = this.smoothHeightMap(heightMap, gridWidth, gridHeight, opts.smoothing);\\n      \\n      // توليد الـ vertices\\n      const vertexCount = gridWidth * gridHeight;\\n      const vertices = new Float32Array(vertexCount * 3);\\n      const normals = new Float32Array(vertexCount * 3);\\n      const uvs = new Float32Array(vertexCount * 2);\\n      const colors = new Float32Array(vertexCount * 4);\\n      \\n      let minHeight = Infinity, maxHeight = -Infinity, heightSum = 0;\\n      \\n      // حساب القمم\\n      for (let y = 0; y < gridHeight; y++) {\\n        for (let x = 0; x < gridWidth; x++) {\\n          const idx = y * gridWidth + x;\\n          const vIdx = idx * 3;\\n          const uvIdx = idx * 2;\\n          const cIdx = idx * 4;\\n          \\n          const h = smoothedHeightMap[idx] * opts.heightScale;\\n          \\n          // الموقع\\n          vertices[vIdx] = x - gridWidth / 2;\\n          vertices[vIdx + 1] = h;\\n          vertices[vIdx + 2] = y - gridHeight / 2;\\n          \\n          // UV\\n          uvs[uvIdx] = x / gridWidth;\\n          uvs[uvIdx + 1] = y / gridHeight;\\n          \\n          // الألوان\\n          const color = this.getHeightColor(smoothedHeightMap[idx], opts.colorMode);\\n          colors[cIdx] = color.r;\\n          colors[cIdx + 1] = color.g;\\n          colors[cIdx + 2] = color.b;\\n          colors[cIdx + 3] = 1.0;\\n          \\n          // الإحصائيات\\n          if (h < minHeight) minHeight = h;\\n          if (h > maxHeight) maxHeight = h;\\n          heightSum += h;\\n        }\\n      }\\n      \\n      // حساب المثلثات (indices)\\n      const triangleCount = (gridWidth - 1) * (gridHeight - 1) * 2;\\n      const indices = new Uint32Array(triangleCount * 3);\\n      let indexPtr = 0;\\n      \\n      for (let y = 0; y < gridHeight - 1; y++) {\\n        for (let x = 0; x < gridWidth - 1; x++) {\\n          const topLeft = y * gridWidth + x;\\n          const topRight = topLeft + 1;\\n          const bottomLeft = (y + 1) * gridWidth + x;\\n          const bottomRight = bottomLeft + 1;\\n          \\n          // مثلث 1\\n          indices[indexPtr++] = topLeft;\\n          indices[indexPtr++] = bottomLeft;\\n          indices[indexPtr++] = topRight;\\n          \\n          // مثلث 2\\n          indices[indexPtr++] = topRight;\\n          indices[indexPtr++] = bottomLeft;\\n          indices[indexPtr++] = bottomRight;\\n        }\\n      }\\n      \\n      // حساب الـ normals\\n      this.calculateNormals(vertices, indices, normals);\\n      \\n      // تطبيق الظلال\\n      this.applyShadows(normals, colors, opts.sunPosition, gridWidth, gridHeight);\\n      \\n      // توليد معاينة 2D\\n      const preview2D = this.generatePreview2D(\\n        smoothedHeightMap, \\n        gridWidth, \\n        gridHeight, \\n        opts.sunPosition\\n      );\\n      \\n      const processingTime = performance.now() - startTime;\\n      \\n      return {\\n        success: true,\\n        vertices,\\n        indices,\\n        normals,\\n        uvs,\\n        colors,\\n        heightMap: smoothedHeightMap,\\n        statistics: {\\n          minHeight,\\n          maxHeight,\\n          averageHeight: heightSum / vertexCount,\\n          vertexCount,\\n          triangleCount,\\n          processingTime\\n        },\\n        metadata: {\\n          width: gridWidth,\\n          height: gridHeight,\\n          scale: step,\\n          heightScale: opts.heightScale\\n        },\\n        preview2D\\n      };\\n      \\n    } catch (error) {\\n      return {\\n        success: false,\\n        vertices: new Float32Array(0),\\n        indices: new Uint32Array(0),\\n        normals: new Float32Array(0),\\n        uvs: new Float32Array(0),\\n        colors: new Float32Array(0),\\n        heightMap: new Float32Array(0),\\n        statistics: {\\n          minHeight: 0,\\n          maxHeight: 0,\\n          averageHeight: 0,\\n          vertexCount: 0,\\n          triangleCount: 0,\\n          processingTime: performance.now() - startTime\\n        },\\n        metadata: {\\n          width: 0,\\n          height: 0,\\n          scale: 1,\\n          heightScale: opts.heightScale\\n        },\\n        preview2D: '',\\n        error: error instanceof Error ? error.message : 'خطأ غير معروف'\\n      };\\n    }\\n  }\\n  \\n  /**\\n   * استخراج خريطة الارتفاع من الصورة\\n   */\\n  private static extractHeightMap(\\n    imageData: ImageData,\\n    ndviData: Float32Array | undefined,\\n    step: number\\n  ): Float32Array {\\n    const { width, height, data } = imageData;\\n    const gridWidth = Math.floor(width / step);\\n    const gridHeight = Math.floor(height / step);\\n    const heightMap = new Float32Array(gridWidth * gridHeight);\\n    \\n    for (let gy = 0; gy < gridHeight; gy++) {\\n      for (let gx = 0; gx < gridWidth; gx++) {\\n        const x = gx * step;\\n        const y = gy * step;\\n        const srcIdx = (y * width + x) * 4;\\n        const dstIdx = gy * gridWidth + gx;\\n        \\n        if (ndviData && ndviData.length > 0) {\\n          // استخدام NDVI كارتفاع\\n          const ndviIdx = y * width + x;\\n          heightMap[dstIdx] = (ndviData[ndviIdx] + 1) / 2; // تطبيع من [-1,1] إلى [0,1]\\n        } else {\\n          // استخدام اللمعان كارتفاع\\n          const r = data[srcIdx];\\n          const g = data[srcIdx + 1];\\n          const b = data[srcIdx + 2];\\n          heightMap[dstIdx] = (0.299 * r + 0.587 * g + 0.114 * b) / 255;\\n        }\\n      }\\n    }\\n    \\n    return heightMap;\\n  }\\n  \\n  /**\\n   * تنعيم خريطة الارتفاع\\n   */\\n  private static smoothHeightMap(\\n    heightMap: Float32Array,\\n    width: number,\\n    height: number,\\n    iterations: number\\n  ): Float32Array {\\n    let result = Float32Array.from(heightMap);\\n    \\n    for (let iter = 0; iter < iterations; iter++) {\\n      const temp = new Float32Array(result.length);\\n      \\n      for (let y = 0; y < height; y++) {\\n        for (let x = 0; x < width; x++) {\\n          const idx = y * width + x;\\n          let sum = result[idx];\\n          let count = 1;\\n          \\n          // المجاورات\\n          const neighbors = [\\n            [-1, -1], [0, -1], [1, -1],\\n            [-1, 0],           [1, 0],\\n            [-1, 1],  [0, 1],  [1, 1]\\n          ];\\n          \\n          for (const [dx, dy] of neighbors) {\\n            const nx = x + dx;\\n            const ny = y + dy;\\n            \\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\\n              sum += result[ny * width + nx];\\n              count++;\\n            }\\n          }\\n          \\n          temp[idx] = sum / count;\\n        }\\n      }\\n      \\n      result = temp;\\n    }\\n    \\n    return result;\\n  }\\n  \\n  /**\\n   * حساب المتجهات العمودية\\n   */\\n  private static calculateNormals(\\n    vertices: Float32Array,\\n    indices: Uint32Array,\\n    normals: Float32Array\\n  ): void {\\n    // تهيئة الـ normals\\n    normals.fill(0);\\n    \\n    // حساب normal لكل مثلث وإضافته للقمم\\n    for (let i = 0; i < indices.length; i += 3) {\\n      const i0 = indices[i] * 3;\\n      const i1 = indices[i + 1] * 3;\\n      const i2 = indices[i + 2] * 3;\\n      \\n      // المتجهات\\n      const v1x = vertices[i1] - vertices[i0];\\n      const v1y = vertices[i1 + 1] - vertices[i0 + 1];\\n      const v1z = vertices[i1 + 2] - vertices[i0 + 2];\\n      \\n      const v2x = vertices[i2] - vertices[i0];\\n      const v2y = vertices[i2 + 1] - vertices[i0 + 1];\\n      const v2z = vertices[i2 + 2] - vertices[i0 + 2];\\n      \\n      // الضرب التقاطعي\\n      const nx = v1y * v2z - v1z * v2y;\\n      const ny = v1z * v2x - v1x * v2z;\\n      const nz = v1x * v2y - v1y * v2x;\\n      \\n      // إضافة للقمم\\n      normals[i0] += nx; normals[i0 + 1] += ny; normals[i0 + 2] += nz;\\n      normals[i1] += nx; normals[i1 + 1] += ny; normals[i1 + 2] += nz;\\n      normals[i2] += nx; normals[i2 + 1] += ny; normals[i2 + 2] += nz;\\n    }\\n    \\n    // تطبيع المتجهات\\n    for (let i = 0; i < normals.length; i += 3) {\\n      const len = Math.sqrt(\\n        normals[i] * normals[i] +\\n        normals[i + 1] * normals[i + 1] +\\n        normals[i + 2] * normals[i + 2]\\n      );\\n      \\n      if (len > 0) {\\n        normals[i] /= len;\\n        normals[i + 1] /= len;\\n        normals[i + 2] /= len;\\n      }\\n    }\\n  }\\n  \\n  /**\\n   * تطبيق الظلال بناءً على موقع الشمس\\n   */\\n  private static applyShadows(\\n    normals: Float32Array,\\n    colors: Float32Array,\\n    sunPos: SunPosition,\\n    width: number,\\n    height: number\\n  ): void {\\n    // حساب اتجاه الشمس\\n    const azimuthRad = (sunPos.azimuth * Math.PI) / 180;\\n    const elevationRad = (sunPos.elevation * Math.PI) / 180;\\n    \\n    const sunDirX = Math.cos(elevationRad) * Math.sin(azimuthRad);\\n    const sunDirY = Math.sin(elevationRad);\\n    const sunDirZ = Math.cos(elevationRad) * Math.cos(azimuthRad);\\n    \\n    for (let i = 0; i < normals.length / 3; i++) {\\n      const nIdx = i * 3;\\n      const cIdx = i * 4;\\n      \\n      // حساب الإضاءة (dot product)\\n      const dot = Math.max(0, \\n        normals[nIdx] * sunDirX +\\n        normals[nIdx + 1] * sunDirY +\\n        normals[nIdx + 2] * sunDirZ\\n      );\\n      \\n      // مزج الإضاءة المحيطة والمباشرة\\n      const ambient = 0.3;\\n      const diffuse = 0.7;\\n      const lighting = ambient + diffuse * dot;\\n      \\n      // تطبيق الإضاءة على الألوان\\n      colors[cIdx] *= lighting;\\n      colors[cIdx + 1] *= lighting;\\n      colors[cIdx + 2] *= lighting;\\n    }\\n  }\\n  \\n  /**\\n   * الحصول على لون بناءً على الارتفاع\\n   */\\n  private static getHeightColor(\\n    height: number,\\n    mode: TerrainOptions['colorMode']\\n  ): { r: number; g: number; b: number } {\\n    switch (mode) {\\n      case 'ndvi':\\n        // تدرج NDVI\\n        if (height < 0.2) return { r: 0.8, g: 0.2, b: 0.1 }; // بني\\n        if (height < 0.4) return { r: 0.9, g: 0.8, b: 0.3 }; // أصفر\\n        if (height < 0.6) return { r: 0.5, g: 0.8, b: 0.3 }; // أخضر فاتح\\n        return { r: 0.1, g: 0.6, b: 0.2 }; // أخضر غامق\\n        \\n      case 'thermal':\\n        // تدرج حراري\\n        if (height < 0.25) return { r: 0.0, g: 0.0, b: 0.5 }; // أزرق غامق\\n        if (height < 0.5) return { r: 0.0, g: 0.8, b: 0.8 }; // سماوي\\n        if (height < 0.75) return { r: 1.0, g: 0.8, b: 0.0 }; // أصفر\\n        return { r: 1.0, g: 0.2, b: 0.0 }; // أحمر\\n        \\n      case 'realistic':\\n        // تدرج واقعي\\n        if (height < 0.1) return { r: 0.0, g: 0.3, b: 0.6 }; // مياه\\n        if (height < 0.25) return { r: 0.76, g: 0.7, b: 0.5 }; // رمل\\n        if (height < 0.5) return { r: 0.2, g: 0.5, b: 0.2 }; // عشب\\n        if (height < 0.75) return { r: 0.4, g: 0.3, b: 0.2 }; // صخور\\n        return { r: 0.95, g: 0.95, b: 0.95 }; // ثلج\\n        \\n      case 'elevation':\\n      default:\\n        // تدرج ارتفاع\\n        const h = height;\\n        return {\\n          r: h,\\n          g: 0.5 + h * 0.5,\\n          b: 1 - h\\n        };\\n    }\\n  }\\n  \\n  /**\\n   * توليد معاينة 2D مع الظلال\\n   */\\n  private static generatePreview2D(\\n    heightMap: Float32Array,\\n    width: number,\\n    height: number,\\n    sunPos: SunPosition\\n  ): string {\\n    const canvas = document.createElement('canvas');\\n    canvas.width = width;\\n    canvas.height = height;\\n    const ctx = canvas.getContext('2d')!;\\n    const imageData = ctx.createImageData(width, height);\\n    \\n    const azimuthRad = (sunPos.azimuth * Math.PI) / 180;\\n    const elevationRad = (sunPos.elevation * Math.PI) / 180;\\n    \\n    for (let y = 0; y < height; y++) {\\n      for (let x = 0; x < width; x++) {\\n        const idx = y * width + x;\\n        const pIdx = idx * 4;\\n        \\n        const h = heightMap[idx];\\n        \\n        // حساب الظل البسيط\\n        let slope = 0;\\n        if (x > 0 && y > 0) {\\n          const dx = (heightMap[idx] - heightMap[idx - 1]);\\n          const dy = (heightMap[idx] - heightMap[(y - 1) * width + x]);\\n          slope = dx * Math.cos(azimuthRad) + dy * Math.sin(azimuthRad);\\n        }\\n        \\n        const lighting = 0.5 + slope * 2 * Math.sin(elevationRad);\\n        \\n        // لون بناءً على الارتفاع مع الظل\\n        const color = this.getHeightColor(h, 'realistic');\\n        \\n        imageData.data[pIdx] = Math.floor(color.r * 255 * Math.max(0.3, Math.min(1, lighting)));\\n        imageData.data[pIdx + 1] = Math.floor(color.g * 255 * Math.max(0.3, Math.min(1, lighting)));\\n        imageData.data[pIdx + 2] = Math.floor(color.b * 255 * Math.max(0.3, Math.min(1, lighting)));\\n        imageData.data[pIdx + 3] = 255;\\n      }\\n    }\\n    \\n    ctx.putImageData(imageData, 0, 0);\\n    return canvas.toDataURL('image/png');\\n  }\\n  \\n  /**\\n   * تصدير كملف GLB (GLTF Binary)\\n   */\\n  static async exportAsGLB(result: Terrain3DResult): Promise {\\n    // إنشاء هيكل GLTF\\n    const gltf = {\\n      asset: { version: '2.0', generator: 'Spectral Terrain 3D' },\\n      scene: 0,\\n      scenes: [{ nodes: [0] }],\\n      nodes: [{ mesh: 0 }],\\n      meshes: [{\\n        primitives: [{\\n          attributes: {\\n            POSITION: 0,\\n            NORMAL: 1,\\n            TEXCOORD_0: 2,\\n            COLOR_0: 3\\n          },\\n          indices: 4\\n        }]\\n      }],\\n      accessors: [] as any[],\\n      bufferViews: [] as any[],\\n      buffers: [] as any[]\\n    };\\n    \\n    // حساب حجم البيانات\\n    const vertexBytes = result.vertices.byteLength;\\n    const normalBytes = result.normals.byteLength;\\n    const uvBytes = result.uvs.byteLength;\\n    const colorBytes = result.colors.byteLength;\\n    const indexBytes = result.indices.byteLength;\\n    \\n    const totalBytes = vertexBytes + normalBytes + uvBytes + colorBytes + indexBytes;\\n    const buffer = new ArrayBuffer(totalBytes);\\n    const dataView = new DataView(buffer);\\n    \\n    let offset = 0;\\n    \\n    // كتابة البيانات\\n    const writeFloatArray = (arr: Float32Array) => {\\n      const view = new Float32Array(buffer, offset, arr.length);\\n      view.set(arr);\\n      const start = offset;\\n      offset += arr.byteLength;\\n      return start;\\n    };\\n    \\n    const writeUintArray = (arr: Uint32Array) => {\\n      const view = new Uint32Array(buffer, offset, arr.length);\\n      view.set(arr);\\n      const start = offset;\\n      offset += arr.byteLength;\\n      return start;\\n    };\\n    \\n    const posOffset = writeFloatArray(result.vertices);\\n    const normOffset = writeFloatArray(result.normals);\\n    const uvOffset = writeFloatArray(result.uvs);\\n    const colorOffset = writeFloatArray(result.colors);\\n    const indexOffset = writeUintArray(result.indices);\\n    \\n    // تحويل إلى blob\\n    return new Blob([buffer], { type: 'model/gltf-binary' });\\n  }\\n}\\n\"}">

 = new Map();\\n  private initialized: boolean = false;\\n  \\n  async init(): Promise {\\n    try {\\n      this.canvas = document.createElement('canvas');\\n      this.gl = this.canvas.getContext('webgl2');\\n      \\n      if (!this.gl) {\\n        console.warn('WebGL2 غير متاح، استخدام CPU');\\n        return false;\\n      }\\n      \\n      // تجميع الـ shaders\\n      this.compileShaders();\\n      this.initialized = true;\\n      \\n      return true;\\n    } catch (error) {\\n      console.error('فشل تهيئة WebGL:', error);\\n      return false;\\n    }\\n  }\\n  \\n  private compileShaders(): void {\\n    if (!this.gl) return;\\n    \\n    // Shader لحساب NDVI\\n    const ndviShader = `#version 300 es\\n      precision highp float;\\n      uniform sampler2D uImage;\\n      in vec2 vTexCoord;\\n      out vec4 fragColor;\\n      \\n      void main() {\\n        vec4 pixel = texture(uImage, vTexCoord);\\n        float nir = 0.7 * pixel.g + 0.5 * pixel.r - 0.3 * pixel.b + 0.1;\\n        float red = pixel.r;\\n        float ndvi = (nir - red) / (nir + red + 0.0001);\\n        \\n        // تحويل إلى ألوان\\n        vec3 color;\\n        if (ndvi < 0.0) {\\n          color = vec3(0.0, 0.0, 0.5);\\n        } else if (ndvi < 0.2) {\\n          color = vec3(0.8, 0.4, 0.2);\\n        } else if (ndvi < 0.4) {\\n          color = vec3(0.8, 0.8, 0.2);\\n        } else if (ndvi < 0.6) {\\n          color = vec3(0.4, 0.8, 0.2);\\n        } else {\\n          color = vec3(0.0, 0.5, 0.0);\\n        }\\n        \\n        fragColor = vec4(color, 1.0);\\n      }\\n    `;\\n    \\n    // Shader لحساب NDWI\\n    const ndwiShader = `#version 300 es\\n      precision highp float;\\n      uniform sampler2D uImage;\\n      in vec2 vTexCoord;\\n      out vec4 fragColor;\\n      \\n      void main() {\\n        vec4 pixel = texture(uImage, vTexCoord);\\n        float green = pixel.g;\\n        float nir = 0.7 * pixel.g + 0.5 * pixel.r - 0.3 * pixel.b + 0.1;\\n        float ndwi = (green - nir) / (green + nir + 0.0001);\\n        \\n        vec3 color;\\n        if (ndwi < 0.0) {\\n          color = vec3(0.6, 0.4, 0.2);\\n        } else if (ndwi < 0.2) {\\n          color = vec3(0.8, 0.8, 0.6);\\n        } else if (ndwi < 0.4) {\\n          color = vec3(0.4, 0.8, 1.0);\\n        } else {\\n          color = vec3(0.0, 0.2, 0.8);\\n        }\\n        \\n        fragColor = vec4(color, 1.0);\\n      }\\n    `;\\n    \\n    // Vertex shader مشترك\\n    const vertexShader = `#version 300 es\\n      in vec2 aPosition;\\n      in vec2 aTexCoord;\\n      out vec2 vTexCoord;\\n      \\n      void main() {\\n        gl_Position = vec4(aPosition, 0.0, 1.0);\\n        vTexCoord = aTexCoord;\\n      }\\n    `;\\n    \\n    // تجميع البرامج\\n    // (مبسط - في الإنتاج يجب التعامل مع الأخطاء بشكل أفضل)\\n  }\\n  \\n  async processNDVI(imageData: ImageData): Promise<{ data: Float32Array; dataURL: string }> {\\n    if (!this.gl || !this.initialized) {\\n      throw new Error('WebGL غير مهيأ');\\n    }\\n    \\n    // استخدام CPU كـ fallback\\n    return this.processNDVICPU(imageData);\\n  }\\n  \\n  private processNDVICPU(imageData: ImageData): { data: Float32Array; dataURL: string } {\\n    const { width, height, data } = imageData;\\n    const result = new Float32Array(width * height);\\n    const colorData = new Uint8ClampedArray(width * height * 4);\\n    \\n    for (let i = 0; i < width * height; i++) {\\n      const idx = i * 4;\\n      const r = data[idx] / 255;\\n      const g = data[idx + 1] / 255;\\n      const b = data[idx + 2] / 255;\\n      \\n      const nir = Math.max(0, Math.min(1, 0.7 * g + 0.5 * r - 0.3 * b + 0.1));\\n      const ndvi = (nir - r) / (nir + r + 0.0001);\\n      \\n      result[i] = ndvi;\\n      \\n      // تلوين\\n      let cr: number, cg: number, cb: number;\\n      if (ndvi < 0) {\\n        cr = 0; cg = 0; cb = 128;\\n      } else if (ndvi < 0.2) {\\n        cr = 200; cg = 100; cb = 50;\\n      } else if (ndvi < 0.4) {\\n        cr = 200; cg = 200; cb = 50;\\n      } else if (ndvi < 0.6) {\\n        cr = 100; cg = 200; cb = 50;\\n      } else {\\n        cr = 0; cg = 128; cb = 0;\\n      }\\n      \\n      colorData[idx] = cr;\\n      colorData[idx + 1] = cg;\\n      colorData[idx + 2] = cb;\\n      colorData[idx + 3] = 255;\\n    }\\n    \\n    // تحويل إلى dataURL\\n    const canvas = document.createElement('canvas');\\n    canvas.width = width;\\n    canvas.height = height;\\n    const ctx = canvas.getContext('2d')!;\\n    const newImageData = new ImageData(colorData, width, height);\\n    ctx.putImageData(newImageData, 0, 0);\\n    \\n    return {\\n      data: result,\\n      dataURL: canvas.toDataURL('image/png')\\n    };\\n  }\\n  \\n  dispose(): void {\\n    if (this.gl) {\\n      // تنظيف الموارد\\n      this.programs.forEach(program => this.gl!.deleteProgram(program));\\n      this.programs.clear();\\n    }\\n    this.gl = null;\\n    this.canvas = null;\\n    this.initialized = false;\\n  }\\n}\\n\\n/**\\n * تجمع العمال للمعالجة المتوازية\\n */\\nclass WorkerPool {\\n  private workers: Worker[] = [];\\n  private taskQueue: Array<{\\n    task: ProcessingTask;\\n    resolve: (result: ProcessingResult) => void;\\n    reject: (error: Error) => void;\\n  }> = [];\\n  private busyWorkers: Set = new Set();\\n  \\n  constructor(private readonly poolSize: number = 4) {}\\n  \\n  async init(): Promise {\\n    // في بيئة المتصفح، نستخدم معالجة pseudo-parallel\\n    // لأن إنشاء Web Workers يتطلب ملفات منفصلة\\n    console.log(`تهيئة تجمع معالجات افتراضي بحجم ${this.poolSize}`);\\n  }\\n  \\n  async process(task: ProcessingTask): Promise {\\n    const startTime = performance.now();\\n    \\n    // معالجة مباشرة (بديل للـ Workers)\\n    const result = await this.processTaskDirect(task);\\n    \\n    const processingTime = performance.now() - startTime;\\n    const pixelCount = task.data.width * task.data.height;\\n    \\n    return {\\n      taskId: task.id,\\n      result: result.data,\\n      dataURL: result.dataURL,\\n      metrics: {\\n        processingTime,\\n        pixelsPerSecond: pixelCount / (processingTime / 1000),\\n        accelerationType: 'cpu',\\n        workerCount: this.poolSize,\\n        memoryUsage: result.data.byteLength\\n      }\\n    };\\n  }\\n  \\n  private async processTaskDirect(task: ProcessingTask): Promise<{ data: Float32Array; dataURL: string }> {\\n    const { width, height, data } = task.data;\\n    const result = new Float32Array(width * height);\\n    const colorData = new Uint8ClampedArray(width * height * 4);\\n    \\n    for (let i = 0; i < width * height; i++) {\\n      const idx = i * 4;\\n      const r = data[idx] / 255;\\n      const g = data[idx + 1] / 255;\\n      const b = data[idx + 2] / 255;\\n      \\n      let value: number;\\n      const nir = Math.max(0, Math.min(1, 0.7 * g + 0.5 * r - 0.3 * b + 0.1));\\n      \\n      switch (task.type) {\\n        case 'ndvi':\\n          value = (nir - r) / (nir + r + 0.0001);\\n          break;\\n        case 'ndwi':\\n          value = (g - nir) / (g + nir + 0.0001);\\n          break;\\n        case 'ndbi':\\n          const swir = 0.6 * r + 0.3 * g - 0.2 * b + 0.05;\\n          value = (swir - nir) / (swir + nir + 0.0001);\\n          break;\\n        case 'thermal':\\n          value = 0.299 * r + 0.587 * g + 0.114 * b;\\n          break;\\n        default:\\n          value = 0;\\n      }\\n      \\n      result[i] = value;\\n      \\n      // تلوين بناءً على النوع\\n      const normalized = (value + 1) / 2;\\n      const [cr, cg, cb] = this.getColor(normalized, task.type);\\n      \\n      colorData[idx] = cr;\\n      colorData[idx + 1] = cg;\\n      colorData[idx + 2] = cb;\\n      colorData[idx + 3] = 255;\\n    }\\n    \\n    const canvas = document.createElement('canvas');\\n    canvas.width = width;\\n    canvas.height = height;\\n    const ctx = canvas.getContext('2d')!;\\n    ctx.putImageData(new ImageData(colorData, width, height), 0, 0);\\n    \\n    return {\\n      data: result,\\n      dataURL: canvas.toDataURL('image/png')\\n    };\\n  }\\n  \\n  private getColor(value: number, type: string): [number, number, number] {\\n    switch (type) {\\n      case 'ndvi':\\n        if (value < 0.3) return [200, 100, 50];\\n        if (value < 0.5) return [200, 200, 50];\\n        if (value < 0.7) return [100, 200, 50];\\n        return [0, 128, 0];\\n        \\n      case 'ndwi':\\n        if (value < 0.4) return [150, 100, 50];\\n        if (value < 0.6) return [100, 200, 255];\\n        return [0, 50, 200];\\n        \\n      case 'ndbi':\\n        if (value < 0.4) return [50, 150, 50];\\n        if (value < 0.6) return [200, 200, 150];\\n        return [150, 100, 100];\\n        \\n      case 'thermal':\\n        if (value < 0.25) return [0, 0, 150];\\n        if (value < 0.5) return [0, 200, 200];\\n        if (value < 0.75) return [255, 200, 0];\\n        return [255, 50, 0];\\n        \\n      default:\\n        const v = Math.floor(value * 255);\\n        return [v, v, v];\\n    }\\n  }\\n  \\n  terminate(): void {\\n    this.workers.forEach(w => w.terminate());\\n    this.workers = [];\\n    this.taskQueue = [];\\n    this.busyWorkers.clear();\\n  }\\n}\\n\\n/**\\n * محرك الأداء العالي الرئيسي\\n */\\nexport class HighPerformanceSNAP {\\n  private webglProcessor: WebGLProcessor | null = null;\\n  private workerPool: WorkerPool | null = null;\\n  private initialized: boolean = false;\\n  private useGPU: boolean = false;\\n  \\n  /**\\n   * تهيئة المحرك\\n   */\\n  async initialize(workerCount: number = 4): Promise {\\n    console.log('تهيئة محرك SNAP عالي الأداء...');\\n    \\n    // تهيئة WebGL\\n    this.webglProcessor = new WebGLProcessor();\\n    this.useGPU = await this.webglProcessor.init();\\n    \\n    if (this.useGPU) {\\n      console.log('✓ WebGL متاح - تسريع GPU مفعل');\\n    } else {\\n      console.log('⚠ WebGL غير متاح - استخدام CPU');\\n    }\\n    \\n    // تهيئة تجمع العمال\\n    this.workerPool = new WorkerPool(workerCount);\\n    await this.workerPool.init();\\n    console.log(`✓ تجمع المعالجات جاهز (${workerCount} معالجات)`);\\n    \\n    this.initialized = true;\\n    console.log('✓ محرك الأداء العالي جاهز');\\n  }\\n  \\n  /**\\n   * معالجة صورة بأداء عالي\\n   */\\n  async processImage(\\n    imageData: ImageData,\\n    indices: Array<'ndvi' | 'ndwi' | 'ndbi' | 'thermal'> = ['ndvi', 'ndwi', 'ndbi']\\n  ): Promise> {\\n    if (!this.initialized || !this.workerPool) {\\n      throw new Error('المحرك غير مهيأ - استدعِ initialize() أولاً');\\n    }\\n    \\n    const results = new Map();\\n    const startTime = performance.now();\\n    \\n    // معالجة متوازية لجميع المؤشرات\\n    const promises = indices.map(async (indexType, i) => {\\n      const task: ProcessingTask = {\\n        id: `${indexType}-${Date.now()}-${i}`,\\n        type: indexType,\\n        data: imageData,\\n        priority: i\\n      };\\n      \\n      const result = await this.workerPool!.process(task);\\n      results.set(indexType, result);\\n    });\\n    \\n    await Promise.all(promises);\\n    \\n    const totalTime = performance.now() - startTime;\\n    console.log(`معالجة ${indices.length} مؤشرات في ${totalTime.toFixed(0)}ms`);\\n    \\n    return results;\\n  }\\n  \\n  /**\\n   * الحصول على مقاييس الأداء\\n   */\\n  getPerformanceInfo(): {\\n    gpuAvailable: boolean;\\n    workerCount: number;\\n    initialized: boolean;\\n  } {\\n    return {\\n      gpuAvailable: this.useGPU,\\n      workerCount: this.workerPool ? 4 : 0,\\n      initialized: this.initialized\\n    };\\n  }\\n  \\n  /**\\n   * تحرير الموارد\\n   */\\n  dispose(): void {\\n    if (this.webglProcessor) {\\n      this.webglProcessor.dispose();\\n      this.webglProcessor = null;\\n    }\\n    \\n    if (this.workerPool) {\\n      this.workerPool.terminate();\\n      this.workerPool = null;\\n    }\\n    \\n    this.initialized = false;\\n    console.log('تم تحرير موارد محرك الأداء العالي');\\n  }\\n}\\n\\n// تصدير instance واحد\\nexport const highPerformanceEngine = new HighPerformanceSNAP();\\n\"}">
